Тестовое задание для CTRL+

==================================================================================================================================
ТЗ:

Цель: Разработать упрощенный программный модуль для центра управления
датчиками умного дома, способного взаимодействовать с датчиками температуры и
передавать данные на центральный сервер через последовательное соединение.
Реализация должна демонстрировать способность кандидата работать с концепциями
RTOS и должна быть разработана с учетом переносимости, в частности для FreeRTOS
или Zephyr RTOS.
Основные Требования
1 Основы RTOS:
o Реализовать очередь для чтения значений датчиков температуры,
датчиков может быть до 256, интервалы опроса (от 100мс до 2 секунд).
o Использовать таймеры RTOS или задержки для тайминга считывания
данных с датчиков.
2 Интерфейс Датчика:
o Разработать простой драйвер для датчика температуры (например, мок-
функцию, если оборудование недоступно), который имитирует чтение
данных температуры.
3 Передача Данных:
o Реализовать механизм отправки данных о температуре на центральный
сервер через последовательный интерфейс (например, UART) в
полнотекстовом формате и бинарном со сжатием, отправка данных по
внешней команде “read\n”, переключение форматов ответа через команду
“toggle\n”.
4 Документация:
o Предоставить инструкции по сборке и запуску приложения, включая
любые необходимые конфигурации для разных RTOS.
* При использовании RTOS Zephyr
• Для RTOS Zephyr показать, как использовать системы логирования или
командного интерфейса для отладки или ввода команд для управления
интервалами чтения датчиков.
• Продемонстрировать использование API управления энергопотреблением
Zephyr для имитации перехода в состояние низкого энергопотребления между
чтениями датчика.

Результаты
• Исходный код приложения мини-центра управления датчиками, включая
скрипты сборки или инструкции.
• Краткий отчет, объясняющий дизайн приложения, особенно как используются
функции RTOS, и руководство по переносу кода на другой RTOS.
==================================================================================================================================

Ход выполенния:
1) Изначально не понятно требование переносимости между RTOS и комментарий "стараться использовать универсальные абстракции и методы rtos (например для управления GPIO не писать напрямую в регистры мк или дергать методы HAL этого мк, а использовать gpio_pin_toggle в случае rtos zephyr)", поэтому сделал как понял.
2) Проект собран под STM32 в STM32CubeIDE.
3) Для выполнения требования переносимости программные модули работы с конкретным МК и конкретной RTOS обёрнуты в интерфейсы:
 а. Файлы mpuinit.c, mpuinit.h реализуют интерфейс для ф-ий работы с конкретным МК;
 б. Файлы rtos_lib.c, rtos_lib.h реализуют интерфейс для ф-ий работы с конкретной RTOS;
 в. В makefile добавлены дефайны STM32_BUILD, FREERTOS_BUILD. Для сборки под Zephyr, дейфайн FREERTOS_BUILD необходимо удалить;
 г. Сборку под Zephyr не проверял, ибо не вышло сходу легко её скачать и собрать под данный МК. Писал по документации с оф сайта;
 д. Для работы с МК реализованы ф-ии настройки тактирования и настройки UART (с прерываниями);
 е. Для работы с RTOS реализованы ф-ии работы с процессами, очередями (сообщениями), семафорами (мьютексами) и таймерами.
3) Реализовал бизнелогику приложеня согласно ТЗ:
 а. Для имитации опроса работы датчиков температуры используется программный модуль sensors (.c/.h). Приложением по прерыванию от таймера запрашивает значения всех 256 датичиков температуры;
 б. Для отправки значений датчиков температуры реализована ф-ия упаковки данных. Данный отправляются либо в целочисленном виде байтами, либо приводятся к строкову виду ("-125, +021");
 в. Для обработки команд управления реализована ф-ия обработки данных от обработчика прерываний UART Rx регистра;
 г. Для отправки данных по UART реализован обработчик прерываний Tx регистра;
 д. Доступ к данным температуры осуществляется через семафор (мьютекс).

Логика работы приложения:
1) По заполнению Rx буфера вызываетс обработчик прерывания UART, который отправляет полученные данные через очередь сообещний в процесс COMMAND;
2) Процесс COMMAND бесконечно ждёт данные из очереди от обработчик апрерываний UART Rx. Процесс обрабатывает входные команды. При команде toggle меняет флаг выдачи данных, при команде read отпрвляет сообщение в процесс UART через очередь сообщений.
3) Процесс UART бесконечно ждёт сообщений от процесса COMMAND. При получении сообщения, процесс поднимает семафор (мьютекс) доступа к данным температуры для блокировки их изменений, упаковывает данный в соответсвии с текущим значением флага типа сообщений и отправляет данные в очередь сообщений для обработчика прерываний UART Tx.
4) Обработчик прерываний UART Tx бесконечно ожидает данных в очередь сообщений для отправки по UART (не очень красиво останавливать обрпботчик прерываний на шедулере ОС, лучше сделать обратную связь от обрабтчика в процесс, а отправлять будет процесс, но сделал побыстрее, ибо времени мало свободного). Получет данный от процесса UART от правляет в интерфейс.
5) Обработчик прерываний таймера обновляет данные о температуре, блокируя к ним доступ на время обновления через семафор.
